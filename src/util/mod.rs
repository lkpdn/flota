use crypto::digest::Digest;
use crypto::md5::Md5;
use ssh2;
use ssh2::{CheckResult, HostKeyType, KnownHostFileKind, KnownHostKeyFormat};
use std::env;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::process::{Command, Stdio};
use url::Url;

pub mod errors;
pub mod ipv4;
pub mod notify;

use self::errors::*;
use self::ipv4::IPv4;

macro_rules! xE {
    ( $x:expr ) => { xE!($x,) };
    ( $x:expr, $($k:ident => $v:expr),* ) => {
    xml::Element::new($x.into(), None, vec![
    $(
        (stringify!($k).into(), None, $v.into()),
    )*])
    }
}

macro_rules! rawCharPtr {
    ( $x:expr ) => {{
    use std::ffi::CString;
    CString::new(format!("{}", $x)).unwrap().as_ptr()
    }}
}

macro_rules! cmd {
    ( $x:expr ) => {{
    let vec = $x.split(" ").collect::<Vec<&str>>();
    let (ref head, ref tail) = vec.split_first().unwrap();
    Command::new(head).args(tail)
    }}
}

/// Update $HOME/.ssh/known_hosts file on host side (where the entire
/// programme is running).
pub fn update_known_host(session: &ssh2::Session, host: &str) -> Result<()> {
    let mut known_hosts = try!(session.known_hosts());
    let file = Path::new(&env::var("HOME").unwrap()).join(".ssh/known_hosts");
    info!("updateing {}", file.to_str().unwrap());
    try!(known_hosts.read_file(&file, KnownHostFileKind::OpenSSH));
    let (key, key_type) = session.host_key().unwrap();
    match known_hosts.check(host, key) {
        CheckResult::Match => return Ok(()),
        CheckResult::NotFound => {}
        CheckResult::Mismatch => {
            for r in known_hosts.iter().filter(|h| match h {
                &Ok(ref h) => h.name() == Some(host),
                _ => false,
            }) {
                try!(known_hosts.remove(r.unwrap()));
            }
        }
        CheckResult::Failure => panic!("failed to check the known hosts"),
    }
    info!("adding {} to the known hosts", host);
    try!(known_hosts.add(host,
                         key,
                         host,
                         match key_type {
                             HostKeyType::Rsa => KnownHostKeyFormat::SshRsa,
                             HostKeyType::Dss => KnownHostKeyFormat::SshDss,
                             HostKeyType::Unknown => panic!("unknown type of key"),
                         }));
    try!(known_hosts.write_file(&file, KnownHostFileKind::OpenSSH));
    Ok(())
}

/// Update /etc/hosts file on host side (where the entire programme
/// is running) to enable ssh login guest node just specifying its
/// hostname.
pub fn update_etc_hosts(path: Option<&Path>, ip: &IPv4, hostname: &str) -> Result<()> {
    let hosts_path: &str = match path {
        Some(v) => v.to_str().unwrap(),
        None => "/etc/hosts",
    };
    // create autogenerated part if not exists.
    {
        let pat =
            format!("/# autogenerated by {}/{{:a;$!{{N;ba}};q;}};$ a\\\\n\\n# autogenerated by \
                     {}\\n# >>>>\\n# <<<<\\n",
                    ::PROGNAME.as_str(),
                    ::PROGNAME.as_str());
        let mut cmd = Command::new("sed");
        cmd.args(&["-i", &pat, hosts_path]);
        info!("pat: {}", pat);
        info!("{:?}", cmd);
        if !cmd.status().expect("failed to execute sed on hosts file").success() {
            return Err("sed on hosts file returned non-zero".into());
        }
    }
    // update entry.
    {
        let pat =
            format!("H;/^$/{{x;/# \
                     autogenerate/{{s/^\\(.*\\n\\){}[^\\n]*\\n\\(.*\\)$/\\1\\2/;s/^\\(.\
                     *\\n\\)\\(# <<<<.*\\)$/\\1{} {}\\n\\2/;p;d;}};p;d;}};d",
                    ip.ip().as_str(),
                    ip.ip().as_str(),
                    hostname);
        let mut cmd = Command::new("sed");
        cmd.args(&["-i", &pat, hosts_path]);
        info!("pat: {}", pat);
        info!("{:?}", cmd);
        if cmd.status().expect("failed to execute sed on hosts file").success() {
            Ok(())
        } else {
            Err("sed on hosts file returned non-zero".into())
        }
    }
}

pub fn download_file<'a>(remote_url: &Url, local_path: &Path) -> Result<()> {
    let option = if local_path.is_dir() { "-P" } else { "-O" };
    match Command::new("wget")
        .args(&[remote_url.as_str(), option, local_path.to_str().unwrap()])
        .stderr(Stdio::null())
        .status() {
        Ok(status) if status.success() => Ok(()),
        Ok(status) => {
            Err(format!("`wget {} {} {}` failed [error: {}]",
                        remote_url.as_str(),
                        option,
                        local_path.to_str().unwrap(),
                        status.code().unwrap())
                .into())
        }
        Err(e) => Err(format!("failed to execute command wget: {}", e).into()),
    }
}

pub fn download_file_md5checked(remote_url: &Url, local_path: &Path, md5: &str) -> Result<()> {
    if !local_path.exists() {
        if let Err(e) = download_file(remote_url, local_path) {
            error!("{}", e);
            return Err(format!("failed to download {} [{}]", remote_url.as_str(), e).into());
        }
    }
    match compare_md5(local_path, md5) {
        Ok(true) => Ok(()),
        Ok(false) => Err("md5 unmatch error".into()),
        Err(e) => Err(e),
    }
}

pub fn compare_md5(local_path: &Path, md5: &str) -> Result<bool> {
    match File::open(local_path.to_str().unwrap()) {
        Ok(mut fl) => {
            let mut buffer = Vec::new();
            fl.read_to_end(&mut buffer).expect("failed to read target file");
            let mut hasher = Md5::new();
            hasher.input(&buffer);
            let md5_local = hasher.result_str();
            return Ok(md5_local == md5);
        }
        Err(e) => {
            return Err(format!("cannot open {} [{}]", local_path.to_str().unwrap(), e).into())
        }
    }
}
